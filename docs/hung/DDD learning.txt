DDD is a software development approach.

Domain (Nghiệp vụ)

DDD layered architecture includes:
- Presentation: GUIs
- Application: Services containing Business logic that uses objects in Domain layer
- Domain: Domain models
- Infrastructure: DBs.
***All business rules must be in Domain layer (particularly in Domain models).

Strategic design: Discuss with Domain expert to design a model using these terms and tools (subdomain, bounded context, event storming, context map,...). The purpose of it is to identify business problems and domain priority.

Domain priority: Core subdomain > Supporting subdomain > Generic subdomain
***Focus on Core subdomain only.

Ubiquitous language: a shared language among developers, domain experts and stakeholders. Discuss with domain expert to unify a language in a context.

Bounded context: used to encapsulate a Ubiquitous language and a Domain model.

Tactical design: Developers build domain models/business logics as solutions to business problems using these building blocks (value object, entity, aggregate, service,...). The purpose is providing business solutions. All business rules reside in domain models. Therefore, the codes have to reflect Domain models.
***Design domain models for Core subdomains only.

Value object: used to contain data.
***Business rules may be in Value object.

Entity: has ID, usually mapped with DB tables.
***Business rules may be in Entity.

Domain service: When you don't know where to put the business logic. That means putting it in a value object, entity, or aggregate is not possible. Then, think about domain services.

Aggregate:
- A collection of multiple entities and value objects that are related to each other.
- Within an aggregate, there is an aggregate root (the aggregate root is also an entity).
- Has an ID (called a global ID). Aggregates communicate with the outside only through the global ID. 
- The objects inside an aggregate must never communicate with the outside directly; everything must go through the aggregate root. 
- The data within an aggregate will be complete and consistent (consistency). 
- WHEN SAVING AN AGGREGATE, IT MUST FOLLOW AN ATOMIC MECHANISM: This means that all information within the aggregate must be successfully saved entirely or not at all. 
- When working with aggregates, do not think about database relationships. Instead, focus on object relations.

The rules for designing aggregates are as follows!
Rule 1: Based on business logic that is always true - True Invariants.
Rule 2: Aggregates should be as small as possible.
Rule 3: Communicate with other Aggregates using global IDs.
Rule 4: Eventual consistency should be used.

Domain event: like normal event (emitting signal to callback).